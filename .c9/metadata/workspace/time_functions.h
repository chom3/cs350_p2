{"filter":false,"title":"time_functions.h","tooltip":"/time_functions.h","undoManager":{"mark":0,"position":0,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":182,"column":0},"action":"insert","lines":["#ifdef time_fns","#else","#define time_fns","#include <sys/timeb.h>","#include <time.h>","","struct timeb timestruct;","// following interfaces are \"exposed\" for user access","void start_timing();","void stop_timing();","double get_wall_clock_diff();","double get_CPU_time_diff();","long get_CPU_time();","void get_wall_time_ints(int *secs, int *msecs); //similar to get_wall_clock, but modifies int parms","void millisleep(int mils); ","","","// following interfaces \"should be only\" for internal use by above functions //(can't hide them in C, need to use C++ for that and","// don't want to use C++ because most users will not be using C++)","void get_wall_clock(time_t *secs, unsigned short *mils);","","// following variables are \"private\" to the functions in this header file","","time_t cs350_timer__time1, cs350_timer__time2;","unsigned short cs350_timer__millitm1, cs350_timer__millitm2;","double cs350_timer__C1,cs350_timer__C2;  // for use by the clock fcn ","double cs350_timer__CPU_start, cs350_timer__CPU_end; // for Linux \"times\" and wintime","// ----------------------- common  ----------------------","void start_timing()  // get start values for wallclock and CPU time","{get_wall_clock(&cs350_timer__time1, &cs350_timer__millitm1);","  cs350_timer__CPU_start=get_CPU_time();","}","","void stop_timing()\t // get final values for wallclock and CPU time","{get_wall_clock(&cs350_timer__time2, &cs350_timer__millitm2);","  cs350_timer__CPU_end=get_CPU_time();","}",""," void get_wall_clock(time_t *secs, unsigned short *mils)"," {\t// wall clock time in all systems","\tftime(&timestruct);","\t*secs=timestruct.time;","\t*mils=timestruct.millitm;"," }",""," void get_wall_time_ints(int *secs, int *msecs)","{","   ftime(&timestruct);","   *secs=(int)timestruct.time;","   *msecs=(int)timestruct.millitm;","}","","double get_wall_clock_diff()","\t{// same for Windows and Linux (uses ftime)","\tdouble fnlt1, fnlt2, realfnl;","\tfnlt1= (double) cs350_timer__time1+(double)cs350_timer__millitm1/1000;","\tfnlt2= (double) cs350_timer__time2+(double)cs350_timer__millitm2/1000;","\trealfnl= (fnlt2-fnlt1); // following values are correctly displayed","\treturn realfnl;","\t}","","#ifndef WIN32","// -------------------------- LINUX ----------------------","#include <sys/times.h>","#include <unistd.h>"," long get_CPU_time()  // integer # of clock_ticks converted into mils"," {struct  tms tmsbuf;\tclock_t x0;double x1, clock_ticks_per_sec;","\t//sysconf() gives # CLOCKS_PER_SEC on Linux","\tclock_ticks_per_sec=sysconf(_SC_CLK_TCK);","\ttimes(&tmsbuf); // clock_t units, Linux only.wx","\tx0=tmsbuf.tms_utime;","\t //must div by clock_ticks_per_sec to get milliseconds","\tx1=(double)x0;","\tx1=1000*(x1/clock_ticks_per_sec); // x0 and x1 are OK","\treturn (long)x1; // long returns whole seconds only, but need the mils"," }","//void millisleep(int mils)","//\t{","//\tusleep(mils*1000);  // note accuracy errors at 1 msec level.","//\t}","","void millisleep(int mils)","\t{struct timespec tmblk;","\ttmblk.tv_sec=mils/1000;","\ttmblk.tv_nsec=(mils%1000)*1000*1000;","\tnanosleep(&tmblk,NULL);  // note accuracy errors at 1 msec level.","\t}","double get_CPU_time_diff()  ","\t// CPU time for Linux","        {double diff; ","\tdiff= (cs350_timer__CPU_end-cs350_timer__CPU_start);","\t//printf(\"Linux cputime diff=%10.3f, diff/1k=%10.3f \\n\",diff, diff/1000);","        return diff/1000;","        }","#else","// ------------------- Windows -------------------","#include <windows.h>","void millisleep(int mils)","\t{","\t\tSleep(mils);","\t}","double get_CPU_time_diff()","\t{//CPU time for Windows","\t\tlong TENMEG=10000000;","\t\treturn(double)(cs350_timer__CPU_end-cs350_timer__CPU_start)/TENMEG;","\t}"," "," long get_CPU_time()"," {int passed;DWORD my_PID;//int junk;","\tHANDLE my_Phandle; //long errnum;","\tFILETIME CreationTime, ExitTime, KernelTime, UserTime;","\t// pointers to above */","\tLPFILETIME lpCreationTime, lpExitTime, lpKernelTime, lpUserTime;","\tlpCreationTime=&CreationTime; lpExitTime=&ExitTime; ","\tlpKernelTime=&KernelTime; lpUserTime=&UserTime;","\t\t","\tmy_PID=GetCurrentProcessId(); /* get the true Process Handle with all privileges */","\tmy_Phandle=OpenProcess(PROCESS_ALL_ACCESS,TRUE,my_PID);","\t//if (my_Phandle==NULL){cout<<\"handle error\";return 1;}","","\t/* ----------------- get all 4 times ----------- */","\tpassed=GetProcessTimes(my_Phandle, ","\t\t lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);// all outputs are FILETIME structures","\t/* next line dies, so don't use it */","\t//passed=QueryProcessCycleTime(my_Phandle, __out pcycles1); // this call gets a \"write to 0\" failure","\tif (!passed) {/*cout<<\"failed with code=\"<<GetLastError(); */return -1;}","\t// following 2 lines are for debugging","\t//cout<<\"USER:highpart=\"<<UserTime.dwHighDateTime<<\"   lowpart=\"<<UserTime.dwLowDateTime<<endl;","\t//cout<<\"KRNL:highpart=\"<<KernelTime.dwHighDateTime<<\"   lowpart=\"<<KernelTime.dwLowDateTime<<endl;","\t","\t/* ----------------- now convert filetime to usable time ---------------------- */","\t/*\tType SYSTEMTIME:","\t\t\t  wYear As Integer","\t\t\t  wMonth As Integer","\t\t\t  wDayOfWeek As Integer","\t\t\t  wDay As Integer","\t\t\t  wHour As Integer","\t\t\t  wMinute As Integer","\t\t\t  wSecond As Integer","\t\t\t  wMilliseconds As Integer","\t\tEnd Type","\t  */","","\t/*","\ttypedef struct _FILETIME ","\t{  DWORD dwLowDateTime;  DWORD dwHighDateTime;","\t} FILETIME,  *PFILETIME;","","\ttypedef union _LARGE_INTEGER ","\t{\tstruct ","\t\t\t{DWORD LowPart; LONG HighPart; };  ","\t\tstruct ","\t\t\t{DWORD LowPart; LONG HighPart; } u;","\t\tLONGLONG QuadPart;","\t} LARGE_INTEGER,  *PLARGE_INTEGER;","","\t*/","\t//SYSTEMTIME systime; SYSTEMTIME* lpsystime; // not currently used","\t//ULARGE_INTEGER outtime;                     //not currently used","\t//lpsystime= &systime;","\t//FileTimeToSystemTime(lpKernelTime,lpsystime); /* now can do math on the parts */","\t//cout<<systime.wMonth<<\" \"<<systime.wDay<<\" \"<<systime.wHour<<\" \"<<systime.wMinute<<\" \"<<systime.wSecond<<\" \"<<systime.wMilliseconds<<endl;;","\treturn UserTime.dwLowDateTime;  // give back the milliseconds since process started.","\t/*It is not recommended that you add and subtract values from the SYSTEMTIME structure to ","\t  obtain relative times. Instead, you should:","","\t\t\t1. Convert the SYSTEMTIME structure to a FILETIME structure. ","\t\t\t2. Copy the resulting FILETIME structure to a ULARGE_INTEGER structure. ","\t\t\t3. Use normal 64-bit arithmetic on the ULARGE_INTEGER value. ","*/","","/*\tIt is not recommended that you add and subtract values from the FILETIME structure ","    to obtain relative times. Instead, you should:","\t1. copy the low- and high-order parts of the file time to a LARGE_INTEGER structure, ","\t2. perform 64-bit arithmetic on the QuadPart member, ","\t3. copy the LowPart and HighPart members into the FILETIME structure.","*/",""," }","#endif","#endif","",""]}]}]]},"ace":{"folds":[],"scrolltop":1655,"scrollleft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":182,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":109,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1423977663000,"hash":"13111767b399e24af90defbacb1abf83894d2b80"}